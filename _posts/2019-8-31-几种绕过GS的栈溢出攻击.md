---
layout: post
title: "几种绕过GS的栈溢出攻击"
---

## GS安全编译选项保护原理 

针对缓冲区溢出时覆盖函数返回地址这一特征, 微软在 `VS 7.0`及以后的VS版本中默认启用了GS安全编译选项，其基本原理如下: 

- 在所有函数发生调用时，向栈帧内压入一个额外的随机`DWORD`, 被称为`canary`或者`Security Cookie`
- `Security Cookie`位于`EBP`之前, 系统还会在`.data`的内存区域存放一个`Security Cookie`副本
- 当栈中发生溢出时,`Security Cookie`将首先被淹没, 之后才是`EBP` 和`返回地址`
- 在函数返回之前, 系统将执行一个额外的安全验证操作, 被称作`Security check`
- 在`Security check`过程中, 系统比较栈帧中原先存放的`Security Cookie`和`.data`中副本的值, 如果两者不吻合, 说明栈帧中的`Security Cookie` 已被破坏, 即栈中发生了溢出
- 若检测到栈中发生溢出, 系统将进入异常处理流程, 函数不会正常返回, `ret`指令也不会被执行
- 采用GS机制, 经典的修改栈帧中函数返回地址的攻击得到了有效遏制

`Security Cookie` 产生细节: 

* 系统以`.data` 节的第一个双字作为`Cookie` 的种子 (所有函数的`Cookie`都使用这个`DWORD`产生) 
* 程序每次运行时`Cookie` 的种子都不同
* 在栈帧初始化以后系统使用`EBP` 异或种子, 作为不同函数的区别
* 在函数返回前, 用`EBP` 异或还原`Cookie`的种子

以下情况不会应用GS: 

- 函数不包含缓冲区, 或缓冲区不是8字节类型且大小不大于4字节
- 函数被定义为具有变量参数列表
- 函数使用无保护的关键字标记
- 函数在第一个语句中包含内嵌汇编代码

## 利用未被保护的内存突破GS









